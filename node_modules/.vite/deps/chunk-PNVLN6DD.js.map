{
  "version": 3,
  "sources": ["../../@vaadin/hilla-react-signals/src/polyfills.ts", "../../nanoid/url-alphabet/index.js", "../../nanoid/index.browser.js", "../../@vaadin/hilla-react-signals/src/events.ts", "../../@vaadin/hilla-react-signals/src/FullStackSignal.ts", "../../@vaadin/hilla-react-signals/src/ValueSignal.ts", "../../@vaadin/hilla-react-signals/src/NumberSignal.ts", "../../@vaadin/hilla-react-signals/src/CollectionSignal.ts", "../../@vaadin/hilla-react-signals/src/ListSignal.ts"],
  "sourcesContent": ["// TODO: Remove this polyfill when we move to ECMA2024\ndeclare global {\n  interface PromiseConstructor {\n    withResolvers<T>(): {\n      resolve(value: T): void;\n      reject(reason?: unknown): void;\n      promise: Promise<T>;\n    };\n  }\n}\n\nif (!('withResolvers' in Promise)) {\n  // eslint-disable-next-line no-extend-native\n  Object.defineProperty(Promise, 'withResolvers', {\n    configurable: true,\n    value<T>() {\n      let resolve: (value: T) => void;\n      let reject: (reason?: unknown) => void;\n      const promise = new Promise<T>((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n      });\n      return { resolve: resolve!, reject: reject!, promise };\n    },\n  });\n}\n\nexport {};\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "import { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "import { nanoid } from 'nanoid';\n\nexport type StateEvent = Readonly<{\n  id: string;\n  type: string;\n  value: unknown;\n  accepted: boolean;\n  parentSignalId?: string;\n}>;\n\n/**\n * Creates a new state event type.\n */\ntype CreateStateEventType<V, T extends string, C extends Record<string, unknown> = Record<never, never>> = Readonly<{\n  type: T;\n  value: V;\n}> &\n  Readonly<C> &\n  StateEvent;\n\n/**\n * A state event received from the server describing the current state of the\n * signal.\n */\nexport type SnapshotStateEvent<T> = CreateStateEventType<T, 'snapshot'>;\n\n/**\n * A state event defines a new value of the signal shared with the server. The\n */\nexport type SetStateEvent<T> = CreateStateEventType<T, 'set'>;\n\nexport function createSetStateEvent<T>(value: T, signalId?: string, parentSignalId?: string): SetStateEvent<T> {\n  return {\n    id: signalId ?? nanoid(),\n    type: 'set',\n    value,\n    accepted: false,\n    ...(parentSignalId !== undefined ? { parentSignalId } : {}),\n  };\n}\n\nexport type ReplaceStateEvent<T> = CreateStateEventType<T, 'replace', { expected: T }>;\n\nexport function createReplaceStateEvent<T>(\n  expected: T,\n  value: T,\n  signalId?: string,\n  parentSignalId?: string,\n): ReplaceStateEvent<T> {\n  return {\n    id: signalId ?? nanoid(),\n    type: 'replace',\n    value,\n    expected,\n    accepted: false,\n    ...(parentSignalId !== undefined ? { parentSignalId } : {}),\n  };\n}\n\nexport type IncrementStateEvent = CreateStateEventType<number, 'increment'>;\n\nexport function createIncrementStateEvent(delta: number): IncrementStateEvent {\n  return {\n    id: nanoid(),\n    type: 'increment',\n    value: delta,\n    accepted: false,\n  };\n}\n\nexport type ListEntry<T> = Readonly<{\n  id: string;\n  prev?: string;\n  next?: string;\n  value: T;\n}>;\n\nexport type ListSnapshotStateEvent<T> = CreateStateEventType<never, 'snapshot', { entries: Array<ListEntry<T>> }>;\n\nexport type InsertLastStateEvent<T> = CreateStateEventType<T, 'insert', { position: 'last'; entryId?: string }>;\n\nexport function createInsertLastStateEvent<T>(value: T): InsertLastStateEvent<T> {\n  return {\n    id: nanoid(),\n    type: 'insert',\n    value,\n    position: 'last',\n    accepted: false,\n  };\n}\n\nexport type RemoveStateEvent = CreateStateEventType<never, 'remove', { entryId: string }>;\n\nexport function createRemoveStateEvent(entryId: string): RemoveStateEvent {\n  return {\n    id: nanoid(),\n    type: 'remove',\n    entryId,\n    value: undefined as never,\n    accepted: false,\n  };\n}\n\nfunction isStateEvent(event: unknown): event is StateEvent {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    typeof (event as { type?: unknown }).type === 'string' &&\n    typeof (event as { value?: unknown }).value !== 'undefined' &&\n    typeof (event as { accepted?: unknown }).accepted === 'boolean'\n  );\n}\n\nexport function isSnapshotStateEvent<T>(event: unknown): event is SnapshotStateEvent<T> {\n  return isStateEvent(event) && event.type === 'snapshot';\n}\n\nexport function isSetStateEvent<T>(event: unknown): event is SetStateEvent<T> {\n  return isStateEvent(event) && event.type === 'set';\n}\n\nexport function isReplaceStateEvent<T>(event: unknown): event is ReplaceStateEvent<T> {\n  return (\n    isStateEvent(event) && typeof (event as { expected?: unknown }).expected !== 'undefined' && event.type === 'replace'\n  );\n}\n\nexport function isIncrementStateEvent(event: unknown): event is IncrementStateEvent {\n  return isStateEvent(event) && event.type === 'increment';\n}\n\nexport function isListSnapshotStateEvent<T>(event: unknown): event is ListSnapshotStateEvent<T> {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    (event as { type?: unknown }).type === 'snapshot' &&\n    (event as { entries?: unknown }).entries instanceof Array &&\n    typeof (event as { accepted?: unknown }).accepted !== 'undefined'\n  );\n}\n\nexport function isInsertLastStateEvent<T>(event: unknown): event is InsertLastStateEvent<T> {\n  return isStateEvent(event) && event.type === 'insert' && (event as { position?: unknown }).position === 'last';\n}\n\nexport function isRemoveStateEvent(event: unknown): event is RemoveStateEvent {\n  return (\n    typeof event === 'object' &&\n    event !== null &&\n    typeof (event as { id?: unknown }).id === 'string' &&\n    (event as { type?: unknown }).type === 'remove' &&\n    typeof (event as { entryId?: unknown }).entryId === 'string' &&\n    typeof (event as { value?: unknown }).value === 'undefined'\n  );\n}\n", "import type { ActionOnLostSubscription, ConnectClient, Subscription } from '@vaadin/hilla-frontend';\nimport { nanoid } from 'nanoid';\nimport { computed, signal, Signal } from './core.js';\nimport { createSetStateEvent, type StateEvent } from './events.js';\n\nconst ENDPOINT = 'SignalsHandler';\n\n/**\n * A return type for signal operations that exposes a `result` property of type\n * `Promise`, that resolves when the operation is completed. It allows defining\n * callbacks to be run after the operation is completed, or error handling when\n * the operation fails.\n *\n * @example\n * ```ts\n * const sharedName = NameService.sharedName({ defaultValue: '' });\n * sharedName.replace('John').result\n *    .then(() => console.log('Name updated successfully'))\n *    .catch((error) => console.error('Failed to update the name:', error));\n * ```\n */\nexport interface Operation {\n  result: Promise<void>;\n}\n\n/**\n * An abstraction of a signal that tracks the number of subscribers, and calls\n * the provided `onSubscribe` and `onUnsubscribe` callbacks for the first\n * subscription and the last unsubscription, respectively.\n * @internal\n */\nexport abstract class DependencyTrackingSignal<T> extends Signal<T> {\n  readonly #onFirstSubscribe: () => void;\n  readonly #onLastUnsubscribe: () => void;\n\n  // -1 means to ignore the first subscription that is created internally in the\n  // FullStackSignal constructor.\n  #subscribeCount = -1;\n\n  protected constructor(value: T | undefined, onFirstSubscribe: () => void, onLastUnsubscribe: () => void) {\n    super(value);\n    this.#onFirstSubscribe = onFirstSubscribe;\n    this.#onLastUnsubscribe = onLastUnsubscribe;\n  }\n\n  protected override S(node: unknown): void {\n    super.S(node);\n    if (this.#subscribeCount === 0) {\n      this.#onFirstSubscribe();\n    }\n    this.#subscribeCount += 1;\n  }\n\n  protected override U(node: unknown): void {\n    super.U(node);\n    this.#subscribeCount -= 1;\n    if (this.#subscribeCount === 0) {\n      this.#onLastUnsubscribe();\n    }\n  }\n}\n\n/**\n * An object that describes a data object to connect to the signal provider\n * service.\n */\nexport type ServerConnectionConfig = Readonly<{\n  /**\n   * The client instance to be used for communication.\n   */\n  client: ConnectClient;\n\n  /**\n   * The name of the signal provider service endpoint.\n   */\n  endpoint: string;\n\n  /**\n   * The name of the signal provider service method.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments to be sent to the endpoint\n   * method that provides the signal when subscribing to it.\n   */\n  params?: Record<string, unknown>;\n\n  /**\n   * The unique identifier of the parent signal in the client.\n   */\n  parentClientSignalId?: string;\n}>;\n\n/**\n * A server connection manager.\n */\nclass ServerConnection {\n  readonly #id: string;\n  readonly config: ServerConnectionConfig;\n  #subscription?: Subscription<StateEvent>;\n\n  constructor(id: string, config: ServerConnectionConfig) {\n    this.config = config;\n    this.#id = id;\n  }\n\n  get subscription() {\n    return this.#subscription;\n  }\n\n  connect() {\n    const { client, endpoint, method, params, parentClientSignalId } = this.config;\n\n    this.#subscription ??= client.subscribe(ENDPOINT, 'subscribe', {\n      providerEndpoint: endpoint,\n      providerMethod: method,\n      clientSignalId: this.#id,\n      params,\n      parentClientSignalId,\n    });\n\n    return this.#subscription;\n  }\n\n  async update(event: StateEvent): Promise<void> {\n    const onTheFly = !this.#subscription;\n\n    if (onTheFly) {\n      this.connect();\n    }\n\n    await this.config.client.call(ENDPOINT, 'update', {\n      clientSignalId: this.#id,\n      event,\n    });\n\n    if (onTheFly) {\n      this.disconnect();\n    }\n  }\n\n  disconnect() {\n    this.#subscription?.cancel();\n    this.#subscription = undefined;\n  }\n}\n\nexport const $update = Symbol('update');\nexport const $processServerResponse = Symbol('processServerResponse');\nexport const $setValueQuietly = Symbol('setValueQuietly');\nexport const $resolveOperation = Symbol('resolveOperation');\nexport const $createOperation = Symbol('createOperation');\n\n/**\n * A signal that holds a shared value. Each change to the value is propagated to\n * the server-side signal provider. At the same time, each change received from\n * the server-side signal provider is propagated to the local signal and it's\n * subscribers.\n *\n * @internal\n */\nexport abstract class FullStackSignal<T> extends DependencyTrackingSignal<T> {\n  /**\n   * The unique identifier of the signal necessary to communicate with the\n   * server.\n   */\n  readonly id: string;\n\n  /**\n   * The server connection manager.\n   */\n  readonly server: ServerConnection;\n\n  /**\n   * Defines whether the signal is currently awaits a server-side response.\n   */\n  readonly pending = computed(() => this.#pending.value);\n\n  /**\n   * Defines whether the signal has an error.\n   */\n  readonly error = computed(() => this.#error.value);\n\n  readonly #pending = signal(false);\n  readonly #error = signal<Error | undefined>(undefined);\n\n  // Paused at the very start to prevent the signal from sending the initial\n  // value to the server.\n  #paused = true;\n\n  constructor(value: T | undefined, config: ServerConnectionConfig, id?: string) {\n    super(\n      value,\n      () => this.#connect(),\n      () => this.#disconnect(),\n    );\n    this.id = id ?? nanoid();\n    this.server = new ServerConnection(this.id, config);\n\n    this.subscribe((v) => {\n      if (!this.#paused) {\n        this.#pending.value = true;\n        this.#error.value = undefined;\n        // For internal signals, the provided non-null to the constructor should\n        // be used along with the parent client side signal id when sending the\n        // set event to the server. For internal signals this combination is\n        // needed for addressing the correct parent/child signal instances on\n        // the server. For a standalone signal, both of them should be passed in\n        // as undefined:\n        const signalId = config.parentClientSignalId !== undefined ? this.id : undefined;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this[$update](createSetStateEvent(v, signalId, config.parentClientSignalId));\n      }\n    });\n\n    this.#paused = false;\n  }\n\n  // stores the promise handlers associated to operations\n  readonly #operationPromises = new Map<\n    string,\n    {\n      resolve(value: PromiseLike<void> | void): void;\n      reject(reason?: any): void;\n    }\n  >();\n\n  // creates the object to be returned by operations to allow defining callbacks\n  protected [$createOperation]({ id, promise }: { id?: string; promise?: Promise<void> }): Operation {\n    const thens = this.#operationPromises;\n    const promises: Array<Promise<void>> = [];\n\n    if (promise) {\n      // Add the provided promise to the list of promises\n      promises.push(promise);\n    }\n\n    if (id) {\n      // Create a promise to be associated to the provided id\n      promises.push(\n        new Promise<void>((resolve, reject) => {\n          thens.set(id, { resolve, reject });\n        }),\n      );\n    }\n\n    if (promises.length === 0) {\n      // If no promises were added, return a resolved promise\n      promises.push(Promise.resolve());\n    }\n\n    return {\n      result: Promise.allSettled(promises).then((results) => {\n        const lastResult = results[results.length - 1];\n        if (lastResult.status === 'fulfilled') {\n          return undefined;\n        }\n        throw lastResult.reason;\n      }),\n    };\n  }\n\n  /**\n   * Sets the local value of the signal without sending any events to the server\n   * @param value - The new value.\n   * @internal\n   */\n  protected [$setValueQuietly](value: T): void {\n    this.#paused = true;\n    super.value = value;\n    this.#paused = false;\n  }\n\n  /**\n   * A method to update the server with the new value.\n   *\n   * @param event - The event to update the server with.\n   * @returns The server response promise.\n   */\n  protected async [$update](event: StateEvent): Promise<void> {\n    return this.server\n      .update(event)\n      .catch((error: unknown) => {\n        this.#error.value = error instanceof Error ? error : new Error(String(error));\n      })\n      .finally(() => {\n        this.#pending.value = false;\n      });\n  }\n\n  /**\n   * Resolves the operation promise associated with the given event id.\n   *\n   * @param eventId - The event id.\n   * @param reason - The reason to reject the promise (if any).\n   */\n  protected [$resolveOperation](eventId: string, reason?: string): void {\n    const operationPromise = this.#operationPromises.get(eventId);\n    if (operationPromise) {\n      this.#operationPromises.delete(eventId);\n      if (reason) {\n        operationPromise.reject(reason);\n      } else {\n        operationPromise.resolve();\n      }\n    }\n  }\n\n  /**\n   * A method with to process the server response. The implementation is\n   * specific for each signal type.\n   *\n   * @param event - The server response event.\n   */\n  protected abstract [$processServerResponse](event: StateEvent): void;\n\n  #connect() {\n    this.server\n      .connect()\n      .onSubscriptionLost(() => 'resubscribe' as ActionOnLostSubscription)\n      .onNext((event: StateEvent) => {\n        this.#paused = true;\n        this[$processServerResponse](event);\n        this.#paused = false;\n      });\n  }\n\n  #disconnect() {\n    if (this.server.subscription === undefined) {\n      return;\n    }\n    this.server.disconnect();\n  }\n}\n", "import { nanoid } from 'nanoid';\nimport {\n  createReplaceStateEvent,\n  createSetStateEvent,\n  isReplaceStateEvent,\n  isSetStateEvent,\n  isSnapshotStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  FullStackSignal,\n  type Operation,\n} from './FullStackSignal.js';\n\ntype PendingRequestsRecord<T> = Readonly<{\n  id: string;\n  callback(value: T): T;\n}> & { canceled: boolean };\n\n/**\n * An operation subscription that can be canceled.\n */\nexport interface OperationSubscription extends Operation {\n  cancel(): void;\n}\n\n/**\n * A full-stack signal that holds an arbitrary value.\n */\nexport class ValueSignal<T> extends FullStackSignal<T> {\n  readonly #pendingRequests = new Map<string, PendingRequestsRecord<T>>();\n\n  /**\n   * Sets the value.\n   * Note that the value change event that is propagated to the server as the\n   * result of this operation is not taking the last seen value into account and\n   * will overwrite the shared value on the server unconditionally (AKA: \"Last\n   * Write Wins\"). If you need to perform a conditional update, use the\n   * `replace` method instead.\n   *\n   * @param value - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  set(value: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createSetStateEvent(value, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    this[$setValueQuietly](value);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Replaces the value with a new one only if the current value is equal to the\n   * expected value.\n   *\n   * @param expected - The expected value.\n   * @param newValue - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  replace(expected: T, newValue: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createReplaceStateEvent(expected, newValue, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Tries to update the value by applying the callback function to the current\n   * value. In case of a concurrent change, the callback is run again with an\n   * updated input value. This is repeated until the result can be applied\n   * without concurrent changes, or the operation is canceled.\n   *\n   * Note that there is no guarantee that cancel() will be effective always,\n   * since a succeeding operation might already be on its way to the server.\n   *\n   * @param callback - The function that is applied on the current value to\n   *                   produce the new value.\n   * @returns An operation object that allows to perform additional actions,\n   *                   including cancellation.\n   */\n  update(callback: (value: T) => T): OperationSubscription {\n    const newValue = callback(this.value);\n    const event = createReplaceStateEvent(this.value, newValue);\n    const promise = this[$update](event);\n    const pendingRequest = { id: nanoid(), callback, canceled: false };\n    this.#pendingRequests.set(event.id, pendingRequest);\n    return {\n      ...this[$createOperation]({ id: pendingRequest.id, promise }),\n      cancel: () => {\n        pendingRequest.canceled = true;\n      },\n    };\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    const record = this.#pendingRequests.get(event.id);\n    if (record) {\n      this.#pendingRequests.delete(event.id);\n\n      if (!(event.accepted || record.canceled)) {\n        this.update(record.callback);\n      }\n    }\n\n    let reason: string | undefined;\n    if (event.accepted || isSnapshotStateEvent<T>(event)) {\n      this.#applyAcceptedEvent(event);\n    } else {\n      reason = `Server rejected the operation with id '${event.id}'. See the server log for more details.`;\n    }\n    // `then` callbacks can be associated to the record or the event\n    // it depends on the operation that was performed\n    [record?.id, event.id].filter(Boolean).forEach((id) => this[$resolveOperation](id!, reason));\n  }\n\n  #applyAcceptedEvent(event: StateEvent): void {\n    if (isSetStateEvent<T>(event) || isSnapshotStateEvent<T>(event)) {\n      this.value = event.value;\n    } else if (isReplaceStateEvent<T>(event)) {\n      if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {\n        this.value = event.value;\n      }\n    }\n  }\n}\n", "import { createIncrementStateEvent, isIncrementStateEvent, type StateEvent } from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  type Operation,\n} from './FullStackSignal.js';\nimport { ValueSignal } from './ValueSignal.js';\n\n/**\n * A signal that holds a number value. The underlying\n * value of this signal is stored and updated as a\n * shared value on the server.\n *\n * After obtaining the NumberSignal instance from\n * a server-side service that returns one, the value\n * can be updated using the `value` property,\n * and it can be read with or without the\n * `value` property (similar to a normal signal):\n *\n * @example\n * ```tsx\n * const counter = CounterService.counter();\n *\n * return (\n *    <Button onClick={() => counter.incrementBy(1)}>\n *      Click count: { counter }\n *    </Button>\n *    <Button onClick={() => counter.value = 0}>Reset</Button>\n * );\n * ```\n */\nexport class NumberSignal extends ValueSignal<number> {\n  readonly #sentIncrementEvents = new Map<string, StateEvent>();\n  /**\n   * Increments the value by the specified delta. The delta can be negative to\n   * decrease the value.\n   *\n   * This method differs from using the `++` or `+=` operators directly on the\n   * signal value. It performs an atomic operation to prevent conflicts from\n   * concurrent changes, ensuring that other users' modifications are not\n   * accidentally overwritten.\n   *\n   * @param delta - The delta to increment the value by. The delta can be\n   * negative.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  incrementBy(delta: number): Operation {\n    if (delta === 0) {\n      return { result: Promise.resolve() };\n    }\n    this[$setValueQuietly](this.value + delta);\n    const event = createIncrementStateEvent(delta);\n    this.#sentIncrementEvents.set(event.id, event);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    if (event.accepted && isIncrementStateEvent(event)) {\n      const sentEvent = this.#sentIncrementEvents.get(event.id);\n      if (sentEvent) {\n        this.#sentIncrementEvents.delete(event.id);\n      } else {\n        this[$setValueQuietly](this.value + event.value);\n      }\n      this[$resolveOperation](event.id);\n    } else {\n      super[$processServerResponse](event);\n    }\n  }\n}\n", "import { FullStackSignal } from './FullStackSignal.js';\n\n/**\n * A {@link FullStackSignal} that represents a collection of values.\n *\n * @typeParam T - The type of the values in the collection.\n */\nexport abstract class CollectionSignal<T> extends FullStackSignal<T> {\n  override get value(): T {\n    return super.value;\n  }\n\n  /**\n   * @readonly\n   */\n  override set value(_: never) {\n    throw new Error('Value of the collection signals cannot be set.');\n  }\n}\n", "import { CollectionSignal } from './CollectionSignal.js';\nimport {\n  createInsertLastStateEvent,\n  createRemoveStateEvent,\n  type InsertLastStateEvent,\n  isInsertLastStateEvent,\n  isListSnapshotStateEvent,\n  isRemoveStateEvent,\n  type ListSnapshotStateEvent,\n  type RemoveStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  type Operation,\n  type ServerConnectionConfig,\n} from './FullStackSignal.js';\nimport { ValueSignal } from './ValueSignal.js';\n\ntype EntryId = string;\ntype Entry<T> = {\n  id: EntryId;\n  value: ValueSignal<T>;\n  next?: EntryId;\n  prev?: EntryId;\n};\n\n/**\n * A {@link FullStackSignal} that represents a shared list of values, where each\n * value is represented by a {@link ValueSignal}.\n * The list can be modified by calling the defined methods to insert or remove\n * items, but the `value` property of a `ListSignal` instance is read-only and\n * cannot be assigned directly.\n * The value of each item in the list can be manipulated similar to a regular\n * {@link ValueSignal}.\n *\n * @typeParam T - The type of the values in the list.\n */\nexport class ListSignal<T> extends CollectionSignal<ReadonlyArray<ValueSignal<T>>> {\n  #head?: EntryId;\n  #tail?: EntryId;\n\n  readonly #values = new Map<string, Entry<T>>();\n\n  constructor(config: ServerConnectionConfig) {\n    const initialValue: Array<ValueSignal<T>> = [];\n    super(initialValue, config);\n  }\n\n  #computeItems(): ReadonlyArray<ValueSignal<T>> {\n    let current = this.#head;\n    const result: Array<ValueSignal<T>> = [];\n    while (current !== undefined) {\n      const entry = this.#values.get(current)!;\n      result.push(entry.value);\n      current = entry.next;\n    }\n    return result;\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    if (!event.accepted) {\n      this[$resolveOperation](\n        event.id,\n        `Server rejected the operation with id '${event.id}'. See the server log for more details.`,\n      );\n      return;\n    }\n    if (isListSnapshotStateEvent<T>(event)) {\n      this.#handleSnapshotEvent(event);\n    } else if (isInsertLastStateEvent<T>(event)) {\n      this.#handleInsertLastUpdate(event);\n    } else if (isRemoveStateEvent(event)) {\n      this.#handleRemoveUpdate(event);\n    }\n    this[$resolveOperation](event.id);\n  }\n\n  #handleInsertLastUpdate(event: InsertLastStateEvent<T>): void {\n    if (event.entryId === undefined) {\n      throw new Error('Unexpected state: Entry id should be defined when insert last event is accepted');\n    }\n    const valueSignal = new ValueSignal<T>(\n      event.value,\n      { ...this.server.config, parentClientSignalId: this.id },\n      event.entryId,\n    );\n    const newEntry: Entry<T> = { id: valueSignal.id, value: valueSignal };\n\n    if (this.#head === undefined) {\n      this.#head = newEntry.id;\n      this.#tail = this.#head;\n    } else {\n      const tailEntry = this.#values.get(this.#tail!)!;\n      tailEntry.next = newEntry.id;\n      newEntry.prev = this.#tail;\n      this.#tail = newEntry.id;\n    }\n    this.#values.set(valueSignal.id, newEntry);\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  #handleRemoveUpdate(event: RemoveStateEvent): void {\n    const entryToRemove = this.#values.get(event.entryId);\n    if (entryToRemove === undefined) {\n      return;\n    }\n    this.#values.delete(event.id);\n    if (this.#head === entryToRemove.id) {\n      if (entryToRemove.next === undefined) {\n        this.#head = undefined;\n        this.#tail = undefined;\n      } else {\n        const newHead = this.#values.get(entryToRemove.next)!;\n        this.#head = newHead.id;\n        newHead.prev = undefined;\n      }\n    } else {\n      const prevEntry = this.#values.get(entryToRemove.prev!)!;\n      const nextEntry = entryToRemove.next !== undefined ? this.#values.get(entryToRemove.next) : undefined;\n      if (nextEntry === undefined) {\n        this.#tail = prevEntry.id;\n        prevEntry.next = undefined;\n      } else {\n        prevEntry.next = nextEntry.id;\n        nextEntry.prev = prevEntry.id;\n      }\n    }\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  #handleSnapshotEvent(event: ListSnapshotStateEvent<T>): void {\n    event.entries.forEach((entry) => {\n      this.#values.set(entry.id, {\n        id: entry.id,\n        prev: entry.prev,\n        next: entry.next,\n        value: new ValueSignal(entry.value, { ...this.server.config, parentClientSignalId: this.id }, entry.id),\n      });\n      if (entry.prev === undefined) {\n        this.#head = entry.id;\n      }\n      if (entry.next === undefined) {\n        this.#tail = entry.id;\n      }\n    });\n    this[$setValueQuietly](this.#computeItems());\n  }\n\n  /**\n   * Inserts a new value at the end of the list.\n   * @param value - The value to insert.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  insertLast(value: T): Operation {\n    const event = createInsertLastStateEvent(value);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Removes the given item from the list.\n   * @param item - The item to remove.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  remove(item: ValueSignal<T>): Operation {\n    const entryToRemove = this.#values.get(item.id);\n    if (entryToRemove === undefined) {\n      return { result: Promise.resolve() };\n    }\n    const removeEvent = createRemoveStateEvent(entryToRemove.value.id);\n    const promise = this[$update](removeEvent);\n    return this[$createOperation]({ id: removeEvent.id, promise });\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
