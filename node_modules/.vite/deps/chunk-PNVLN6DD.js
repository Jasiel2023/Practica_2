import {
  d,
  u,
  w
} from "./chunk-PTVTUJK6.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-547O27LD.js";

// node_modules/@vaadin/hilla-react-signals/polyfills.js
if (!("withResolvers" in Promise)) {
  Object.defineProperty(Promise, "withResolvers", {
    configurable: true,
    value() {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      return { resolve, reject, promise };
    }
  });
}

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// node_modules/@vaadin/hilla-react-signals/events.js
function createSetStateEvent(value, signalId, parentSignalId) {
  return {
    id: signalId ?? nanoid(),
    type: "set",
    value,
    accepted: false,
    ...parentSignalId !== void 0 ? { parentSignalId } : {}
  };
}
function createReplaceStateEvent(expected, value, signalId, parentSignalId) {
  return {
    id: signalId ?? nanoid(),
    type: "replace",
    value,
    expected,
    accepted: false,
    ...parentSignalId !== void 0 ? { parentSignalId } : {}
  };
}
function createIncrementStateEvent(delta) {
  return {
    id: nanoid(),
    type: "increment",
    value: delta,
    accepted: false
  };
}
function createInsertLastStateEvent(value) {
  return {
    id: nanoid(),
    type: "insert",
    value,
    position: "last",
    accepted: false
  };
}
function createRemoveStateEvent(entryId) {
  return {
    id: nanoid(),
    type: "remove",
    entryId,
    value: void 0,
    accepted: false
  };
}
function isStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && typeof event.type === "string" && typeof event.value !== "undefined" && typeof event.accepted === "boolean";
}
function isSnapshotStateEvent(event) {
  return isStateEvent(event) && event.type === "snapshot";
}
function isSetStateEvent(event) {
  return isStateEvent(event) && event.type === "set";
}
function isReplaceStateEvent(event) {
  return isStateEvent(event) && typeof event.expected !== "undefined" && event.type === "replace";
}
function isIncrementStateEvent(event) {
  return isStateEvent(event) && event.type === "increment";
}
function isListSnapshotStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && event.type === "snapshot" && event.entries instanceof Array && typeof event.accepted !== "undefined";
}
function isInsertLastStateEvent(event) {
  return isStateEvent(event) && event.type === "insert" && event.position === "last";
}
function isRemoveStateEvent(event) {
  return typeof event === "object" && event !== null && typeof event.id === "string" && event.type === "remove" && typeof event.entryId === "string" && typeof event.value === "undefined";
}

// node_modules/@vaadin/hilla-react-signals/FullStackSignal.js
var ENDPOINT = "SignalsHandler";
var _onFirstSubscribe, _onLastUnsubscribe, _subscribeCount;
var DependencyTrackingSignal = class extends u {
  constructor(value, onFirstSubscribe, onLastUnsubscribe) {
    super(value);
    __privateAdd(this, _onFirstSubscribe);
    __privateAdd(this, _onLastUnsubscribe);
    __privateAdd(this, _subscribeCount, -1);
    __privateSet(this, _onFirstSubscribe, onFirstSubscribe);
    __privateSet(this, _onLastUnsubscribe, onLastUnsubscribe);
  }
  S(node) {
    super.S(node);
    if (__privateGet(this, _subscribeCount) === 0) {
      __privateGet(this, _onFirstSubscribe).call(this);
    }
    __privateSet(this, _subscribeCount, __privateGet(this, _subscribeCount) + 1);
  }
  U(node) {
    super.U(node);
    __privateSet(this, _subscribeCount, __privateGet(this, _subscribeCount) - 1);
    if (__privateGet(this, _subscribeCount) === 0) {
      __privateGet(this, _onLastUnsubscribe).call(this);
    }
  }
};
_onFirstSubscribe = new WeakMap();
_onLastUnsubscribe = new WeakMap();
_subscribeCount = new WeakMap();
var _id, _subscription;
var ServerConnection = class {
  constructor(id, config) {
    __privateAdd(this, _id);
    __publicField(this, "config");
    __privateAdd(this, _subscription);
    this.config = config;
    __privateSet(this, _id, id);
  }
  get subscription() {
    return __privateGet(this, _subscription);
  }
  connect() {
    const { client, endpoint, method, params, parentClientSignalId } = this.config;
    __privateGet(this, _subscription) ?? __privateSet(this, _subscription, client.subscribe(ENDPOINT, "subscribe", {
      providerEndpoint: endpoint,
      providerMethod: method,
      clientSignalId: __privateGet(this, _id),
      params,
      parentClientSignalId
    }));
    return __privateGet(this, _subscription);
  }
  async update(event) {
    const onTheFly = !__privateGet(this, _subscription);
    if (onTheFly) {
      this.connect();
    }
    await this.config.client.call(ENDPOINT, "update", {
      clientSignalId: __privateGet(this, _id),
      event
    });
    if (onTheFly) {
      this.disconnect();
    }
  }
  disconnect() {
    var _a;
    (_a = __privateGet(this, _subscription)) == null ? void 0 : _a.cancel();
    __privateSet(this, _subscription, void 0);
  }
};
_id = new WeakMap();
_subscription = new WeakMap();
var $update = Symbol("update");
var $processServerResponse = Symbol("processServerResponse");
var $setValueQuietly = Symbol("setValueQuietly");
var $resolveOperation = Symbol("resolveOperation");
var $createOperation = Symbol("createOperation");
var _pending, _error, _paused, _operationPromises, _FullStackSignal_instances, connect_fn, disconnect_fn;
var FullStackSignal = class extends DependencyTrackingSignal {
  constructor(value, config, id) {
    super(value, () => __privateMethod(this, _FullStackSignal_instances, connect_fn).call(this), () => __privateMethod(this, _FullStackSignal_instances, disconnect_fn).call(this));
    __privateAdd(this, _FullStackSignal_instances);
    __publicField(this, "id");
    __publicField(this, "server");
    __publicField(this, "pending", w(() => __privateGet(this, _pending).value));
    __publicField(this, "error", w(() => __privateGet(this, _error).value));
    __privateAdd(this, _pending, d(false));
    __privateAdd(this, _error, d(void 0));
    __privateAdd(this, _paused, true);
    __privateAdd(this, _operationPromises, /* @__PURE__ */ new Map());
    this.id = id ?? nanoid();
    this.server = new ServerConnection(this.id, config);
    this.subscribe((v) => {
      if (!__privateGet(this, _paused)) {
        __privateGet(this, _pending).value = true;
        __privateGet(this, _error).value = void 0;
        const signalId = config.parentClientSignalId !== void 0 ? this.id : void 0;
        this[$update](createSetStateEvent(v, signalId, config.parentClientSignalId));
      }
    });
    __privateSet(this, _paused, false);
  }
  [$createOperation]({ id, promise }) {
    const thens = __privateGet(this, _operationPromises);
    const promises = [];
    if (promise) {
      promises.push(promise);
    }
    if (id) {
      promises.push(new Promise((resolve, reject) => {
        thens.set(id, { resolve, reject });
      }));
    }
    if (promises.length === 0) {
      promises.push(Promise.resolve());
    }
    return {
      result: Promise.allSettled(promises).then((results) => {
        const lastResult = results[results.length - 1];
        if (lastResult.status === "fulfilled") {
          return void 0;
        }
        throw lastResult.reason;
      })
    };
  }
  [$setValueQuietly](value) {
    __privateSet(this, _paused, true);
    super.value = value;
    __privateSet(this, _paused, false);
  }
  async [$update](event) {
    return this.server.update(event).catch((error) => {
      __privateGet(this, _error).value = error instanceof Error ? error : new Error(String(error));
    }).finally(() => {
      __privateGet(this, _pending).value = false;
    });
  }
  [$resolveOperation](eventId, reason) {
    const operationPromise = __privateGet(this, _operationPromises).get(eventId);
    if (operationPromise) {
      __privateGet(this, _operationPromises).delete(eventId);
      if (reason) {
        operationPromise.reject(reason);
      } else {
        operationPromise.resolve();
      }
    }
  }
};
_pending = new WeakMap();
_error = new WeakMap();
_paused = new WeakMap();
_operationPromises = new WeakMap();
_FullStackSignal_instances = new WeakSet();
connect_fn = function() {
  this.server.connect().onSubscriptionLost(() => "resubscribe").onNext((event) => {
    __privateSet(this, _paused, true);
    this[$processServerResponse](event);
    __privateSet(this, _paused, false);
  });
};
disconnect_fn = function() {
  if (this.server.subscription === void 0) {
    return;
  }
  this.server.disconnect();
};

// node_modules/@vaadin/hilla-react-signals/ValueSignal.js
var _pendingRequests, _ValueSignal_instances, applyAcceptedEvent_fn;
var ValueSignal = class extends FullStackSignal {
  constructor() {
    super(...arguments);
    __privateAdd(this, _ValueSignal_instances);
    __privateAdd(this, _pendingRequests, /* @__PURE__ */ new Map());
  }
  set(value) {
    const { parentClientSignalId } = this.server.config;
    const signalId = parentClientSignalId !== void 0 ? this.id : void 0;
    const event = createSetStateEvent(value, signalId, parentClientSignalId);
    const promise = this[$update](event);
    this[$setValueQuietly](value);
    return this[$createOperation]({ id: event.id, promise });
  }
  replace(expected, newValue) {
    const { parentClientSignalId } = this.server.config;
    const signalId = parentClientSignalId !== void 0 ? this.id : void 0;
    const event = createReplaceStateEvent(expected, newValue, signalId, parentClientSignalId);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  update(callback) {
    const newValue = callback(this.value);
    const event = createReplaceStateEvent(this.value, newValue);
    const promise = this[$update](event);
    const pendingRequest = { id: nanoid(), callback, canceled: false };
    __privateGet(this, _pendingRequests).set(event.id, pendingRequest);
    return {
      ...this[$createOperation]({ id: pendingRequest.id, promise }),
      cancel: () => {
        pendingRequest.canceled = true;
      }
    };
  }
  [$processServerResponse](event) {
    const record = __privateGet(this, _pendingRequests).get(event.id);
    if (record) {
      __privateGet(this, _pendingRequests).delete(event.id);
      if (!(event.accepted || record.canceled)) {
        this.update(record.callback);
      }
    }
    let reason;
    if (event.accepted || isSnapshotStateEvent(event)) {
      __privateMethod(this, _ValueSignal_instances, applyAcceptedEvent_fn).call(this, event);
    } else {
      reason = `Server rejected the operation with id '${event.id}'. See the server log for more details.`;
    }
    [record == null ? void 0 : record.id, event.id].filter(Boolean).forEach((id) => this[$resolveOperation](id, reason));
  }
};
_pendingRequests = new WeakMap();
_ValueSignal_instances = new WeakSet();
applyAcceptedEvent_fn = function(event) {
  if (isSetStateEvent(event) || isSnapshotStateEvent(event)) {
    this.value = event.value;
  } else if (isReplaceStateEvent(event)) {
    if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {
      this.value = event.value;
    }
  }
};

// node_modules/@vaadin/hilla-react-signals/NumberSignal.js
var _sentIncrementEvents;
var NumberSignal = class extends ValueSignal {
  constructor() {
    super(...arguments);
    __privateAdd(this, _sentIncrementEvents, /* @__PURE__ */ new Map());
  }
  incrementBy(delta) {
    if (delta === 0) {
      return { result: Promise.resolve() };
    }
    this[$setValueQuietly](this.value + delta);
    const event = createIncrementStateEvent(delta);
    __privateGet(this, _sentIncrementEvents).set(event.id, event);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  [$processServerResponse](event) {
    if (event.accepted && isIncrementStateEvent(event)) {
      const sentEvent = __privateGet(this, _sentIncrementEvents).get(event.id);
      if (sentEvent) {
        __privateGet(this, _sentIncrementEvents).delete(event.id);
      } else {
        this[$setValueQuietly](this.value + event.value);
      }
      this[$resolveOperation](event.id);
    } else {
      super[$processServerResponse](event);
    }
  }
};
_sentIncrementEvents = new WeakMap();

// node_modules/@vaadin/hilla-react-signals/CollectionSignal.js
var CollectionSignal = class extends FullStackSignal {
  get value() {
    return super.value;
  }
  set value(_) {
    throw new Error("Value of the collection signals cannot be set.");
  }
};

// node_modules/@vaadin/hilla-react-signals/ListSignal.js
var _head, _tail, _values, _ListSignal_instances, computeItems_fn, handleInsertLastUpdate_fn, handleRemoveUpdate_fn, handleSnapshotEvent_fn;
var ListSignal = class extends CollectionSignal {
  constructor(config) {
    const initialValue = [];
    super(initialValue, config);
    __privateAdd(this, _ListSignal_instances);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _values, /* @__PURE__ */ new Map());
  }
  [$processServerResponse](event) {
    if (!event.accepted) {
      this[$resolveOperation](event.id, `Server rejected the operation with id '${event.id}'. See the server log for more details.`);
      return;
    }
    if (isListSnapshotStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleSnapshotEvent_fn).call(this, event);
    } else if (isInsertLastStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleInsertLastUpdate_fn).call(this, event);
    } else if (isRemoveStateEvent(event)) {
      __privateMethod(this, _ListSignal_instances, handleRemoveUpdate_fn).call(this, event);
    }
    this[$resolveOperation](event.id);
  }
  insertLast(value) {
    const event = createInsertLastStateEvent(value);
    const promise = this[$update](event);
    return this[$createOperation]({ id: event.id, promise });
  }
  remove(item) {
    const entryToRemove = __privateGet(this, _values).get(item.id);
    if (entryToRemove === void 0) {
      return { result: Promise.resolve() };
    }
    const removeEvent = createRemoveStateEvent(entryToRemove.value.id);
    const promise = this[$update](removeEvent);
    return this[$createOperation]({ id: removeEvent.id, promise });
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_values = new WeakMap();
_ListSignal_instances = new WeakSet();
computeItems_fn = function() {
  let current = __privateGet(this, _head);
  const result = [];
  while (current !== void 0) {
    const entry = __privateGet(this, _values).get(current);
    result.push(entry.value);
    current = entry.next;
  }
  return result;
};
handleInsertLastUpdate_fn = function(event) {
  if (event.entryId === void 0) {
    throw new Error("Unexpected state: Entry id should be defined when insert last event is accepted");
  }
  const valueSignal = new ValueSignal(event.value, { ...this.server.config, parentClientSignalId: this.id }, event.entryId);
  const newEntry = { id: valueSignal.id, value: valueSignal };
  if (__privateGet(this, _head) === void 0) {
    __privateSet(this, _head, newEntry.id);
    __privateSet(this, _tail, __privateGet(this, _head));
  } else {
    const tailEntry = __privateGet(this, _values).get(__privateGet(this, _tail));
    tailEntry.next = newEntry.id;
    newEntry.prev = __privateGet(this, _tail);
    __privateSet(this, _tail, newEntry.id);
  }
  __privateGet(this, _values).set(valueSignal.id, newEntry);
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};
handleRemoveUpdate_fn = function(event) {
  const entryToRemove = __privateGet(this, _values).get(event.entryId);
  if (entryToRemove === void 0) {
    return;
  }
  __privateGet(this, _values).delete(event.id);
  if (__privateGet(this, _head) === entryToRemove.id) {
    if (entryToRemove.next === void 0) {
      __privateSet(this, _head, void 0);
      __privateSet(this, _tail, void 0);
    } else {
      const newHead = __privateGet(this, _values).get(entryToRemove.next);
      __privateSet(this, _head, newHead.id);
      newHead.prev = void 0;
    }
  } else {
    const prevEntry = __privateGet(this, _values).get(entryToRemove.prev);
    const nextEntry = entryToRemove.next !== void 0 ? __privateGet(this, _values).get(entryToRemove.next) : void 0;
    if (nextEntry === void 0) {
      __privateSet(this, _tail, prevEntry.id);
      prevEntry.next = void 0;
    } else {
      prevEntry.next = nextEntry.id;
      nextEntry.prev = prevEntry.id;
    }
  }
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};
handleSnapshotEvent_fn = function(event) {
  event.entries.forEach((entry) => {
    __privateGet(this, _values).set(entry.id, {
      id: entry.id,
      prev: entry.prev,
      next: entry.next,
      value: new ValueSignal(entry.value, { ...this.server.config, parentClientSignalId: this.id }, entry.id)
    });
    if (entry.prev === void 0) {
      __privateSet(this, _head, entry.id);
    }
    if (entry.next === void 0) {
      __privateSet(this, _tail, entry.id);
    }
  });
  this[$setValueQuietly](__privateMethod(this, _ListSignal_instances, computeItems_fn).call(this));
};

export {
  FullStackSignal,
  ValueSignal,
  NumberSignal,
  ListSignal
};
//# sourceMappingURL=chunk-PNVLN6DD.js.map
